decl byte* malloc(int sz);
decl void free(byte* ptr);
decl void memset(byte* ptr, byte val, int sz);
decl void printf(char* fmt, ...);
decl void putchar(char);

decl long clock();

public void run {
	double start = (double) (clock());
	
	int passes = 0;
	Sieve test;
	while ((clock() - start) < 5000000) {
		test = sieve(1000000);
		passes += 1;
	}
	
	double end = (double) (clock());
	
	printSieve(false, test, (end - start) * 1000000, passes);
}

struct Sieve {
	int count,
	int n,
	bool* prime,
}

char* bool2str(bool b) {
	if (b)
		ret 'true';
	ret 'false';
}

bool validate(Sieve test) {
	if (test.n == 10)
		ret test.count == 1;
	if (test.n == 100)
		ret test.count == 25;
	if (test.n == 1000)
		ret test.count == 168;
	if (test.n == 10000)
		ret test.count == 1229;
	if (test.n == 100000)
		ret test.count == 9592;
	if (test.n == 1000000)
		ret test.count == 78498;
	if (test.n == 10000000)
		ret test.count == 664579;
	if (test.n == 100000000)
		ret test.count == 5761455;
	ret false;
}

void printSieve(bool showResults, Sieve test, double duration, int passes) {
	for (int p = 2; p <= test.n; p += 1)
		if (test.prime[p]) {
			printf('%i\n', p);
		}
	
	printf('Passes: %i, Time: %f, Avg: %f, Limit: %i, Count: %i, Valid: %s\n', passes, duration, duration / (double) passes, test.n, test.count, bool2str(validate(test)));
}

Sieve sieve(int n) {
	bool* prime = malloc(n + 1);
	memset(prime, true to byte, n + 1);
	
	int count = n - 1;
	
	for (int p = 2; p * p <= n; p += 1) {
		if (prime[p]) {
			for (int i = p * p; i <= n; i += p) {
				if (prime[i])
					count -= 1;
				prime[i] = false;
			}
		}
	}
	

	free(prime);
	ret Sieve { count, n, prime };
}