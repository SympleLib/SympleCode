module 'simple-code' {
	LLVMDefaultVisibility decl void puts(char* str = null): 'puts'

	LLVMDefaultVisibility decl void printf(char* fmt = null, ...): 'printf'

	LLVMDefaultVisibility link sieve.sy
}
---
module 'simple-code' {
		LLVMDefaultVisibility decl byte* malloc(int sz = null): 'malloc'

	LLVMDefaultVisibility decl void free(byte* ptr = null): 'free'

	LLVMDefaultVisibility decl void memset(byte* ptr = null, byte val = null, int sz = null): 'memset'

	LLVMDefaultVisibility decl void printf(char* fmt = null, ...): 'printf'

	LLVMDefaultVisibility decl void putchar(char  = null): 'putchar'

	LLVMDefaultVisibility decl long clock(): 'clock'

	LLVMDefaultVisibility void run(): 'run' {
			LLVMDefaultVisibility long start: 'start' = &clock()
			LLVMDefaultVisibility int passes: 'passes' = 0
			LLVMDefaultVisibility Sieve test: 'test' = null
			while (LLVMIntSLT
				LLVMSub
					&clock()
					start
				10000)
			{
				Eql
					test
					&sieve(1000000)
				PlusEql
					passes
					1
			}
			LLVMDefaultVisibility long end: 'end' = &clock()
			&printSieve(False, test, LLVMSDiv
				LLVMSub
					end
					start to double
				1000, passes)
		}

	LLVMDefaultVisibility struct Sieve {
			LLVMDefaultVisibility int n = null
			LLVMDefaultVisibility bool* prime = null
		}

	LLVMDefaultVisibility char* bool2str(bool b = null): 'bool2str' {
			if (b)
			ret 'true'
			ret 'false'
		}

	LLVMDefaultVisibility bool validate(Sieve test = null, int count = null): 'validate' {
			if (LLVMIntEQ
				test.n
				10)
			ret LLVMIntEQ
				count
				1
			if (LLVMIntEQ
				test.n
				100)
			ret LLVMIntEQ
				count
				25
			if (LLVMIntEQ
				test.n
				1000)
			ret LLVMIntEQ
				count
				168
			if (LLVMIntEQ
				test.n
				10000)
			ret LLVMIntEQ
				count
				1229
			if (LLVMIntEQ
				test.n
				100000)
			ret LLVMIntEQ
				count
				9592
			if (LLVMIntEQ
				test.n
				1000000)
			ret LLVMIntEQ
				count
				78498
			if (LLVMIntEQ
				test.n
				10000000)
			ret LLVMIntEQ
				count
				664579
			if (LLVMIntEQ
				test.n
				100000000)
			ret LLVMIntEQ
				count
				5761455
			ret False
		}

	LLVMDefaultVisibility void printSieve(bool showResults = null, Sieve test = null, double duration = null, int passes = null): 'printSieve' {
			LLVMDefaultVisibility int count: 'count' = 0
			for (LLVMDefaultVisibility int p: 'p' = 2
			LLVMIntSLE
				p
				test.n
			PlusEql
				p
				1)
			if (test.prime[p])
			{
				if (showResults)
				&printf('%i, ', p)
				PlusEql
					count
					1
			}
			&printf('Passes: %i, Time: %f, Avg: %f, Limit: %i, Count: %i, Valid: %s
', passes, duration, LLVMSDiv
				duration
				passes to double, test.n, count, &bool2str(&validate(test, count)))
		}

	LLVMDefaultVisibility Sieve sieve(int n = null): 'sieve' {
			LLVMDefaultVisibility bool* prime: 'prime' = &malloc(LLVMAdd
				n
				1)
			&memset(prime, True to byte, LLVMAdd
				n
				1)
			for (LLVMDefaultVisibility int p: 'p' = 2
			LLVMIntSLE
				LLVMMul
					p
					p
				n
			PlusEql
				p
				1)
			{
				if (prime[p])
				{
					for (LLVMDefaultVisibility int i: 'i' = LLVMMul
						p
						p
					LLVMIntSLE
						i
						n
					PlusEql
						i
						p)
					{
						Eql
							prime[i]
							False
					}
				}
			}
			&free(prime)
			ret Sieve { n, prime }
		}
}
---
; ModuleID = 'simple-code'
source_filename = "simple-code"

%Sieve = type { i32, i1* }

declare void @puts(i8*)

declare void @printf(i8*, ...)

declare i8* @malloc(i32)

declare void @free(i8*)

declare void @memset(i8*, i8, i32)

declare void @printf.1(i8*, ...)

declare void @putchar(i8)

declare i64 @clock()

declare void @run()

declare i8* @bool2str(i1)

declare i1 @validate(%Sieve, i32)

declare void @printSieve(i1, %Sieve, double, i32)

declare %Sieve @sieve(i32)

; ModuleID = 'simple-code'
source_filename = "simple-code"

%Sieve = type { i32, i1* }

@0 = private unnamed_addr constant [5 x i8] c"true\00", align 1
@1 = private unnamed_addr constant [6 x i8] c"false\00", align 1
@2 = private unnamed_addr constant [5 x i8] c"%i, \00", align 1
@3 = private unnamed_addr constant [64 x i8] c"Passes: %i, Time: %f, Avg: %f, Limit: %i, Count: %i, Valid: %s\0A\00", align 1

declare i8* @malloc(i32)

declare void @free(i8*)

declare void @memset(i8*, i8, i32)

declare void @printf(i8*, ...)

declare void @putchar(i8)

declare i64 @clock()

define void @run() {
  %1 = call i64 @clock()
  %start = alloca i64, align 8
  store i64 %1, i64* %start, align 4
  %passes = alloca i32, align 4
  store i32 0, i32* %passes, align 4
  %2 = alloca %Sieve, align 8
  %3 = getelementptr inbounds %Sieve, %Sieve* %2, i32 0, i32 0
  store i32 0, i32* %3, align 4
  %4 = getelementptr inbounds %Sieve, %Sieve* %2, i32 0, i32 1
  store i1* null, i1** %4, align 8
  %5 = load %Sieve, %Sieve* %2, align 8
  %test = alloca %Sieve, align 8
  store %Sieve %5, %Sieve* %test, align 8
  br label %while-loop

while-loop:                                       ; preds = %while-then, %0
  %6 = call i64 @clock()
  %7 = load i64, i64* %start, align 4
  %8 = sub i64 %6, %7
  %9 = icmp slt i64 %8, 10000
  br i1 %9, label %while-then, label %while-end

while-then:                                       ; preds = %while-loop
  %10 = load %Sieve, %Sieve* %test, align 8
  %11 = call %Sieve @sieve(i32 1000000)
  store %Sieve %11, %Sieve* %test, align 8
  %12 = load i32, i32* %passes, align 4
  %13 = add i32 %12, 1
  store i32 %13, i32* %passes, align 4
  br label %while-loop

while-end:                                        ; preds = %while-loop
  %14 = call i64 @clock()
  %end = alloca i64, align 8
  store i64 %14, i64* %end, align 4
  %15 = load %Sieve, %Sieve* %test, align 8
  %16 = load i64, i64* %end, align 4
  %17 = load i64, i64* %start, align 4
  %18 = sub i64 %16, %17
  %19 = sitofp i64 %18 to double
  %20 = fdiv double %19, 1.000000e+03
  %21 = load i32, i32* %passes, align 4
  call void @printSieve(i1 false, %Sieve %15, double %20, i32 %21)
  ret void
}

define i8* @bool2str(i1 %0) {
  %2 = alloca i1, align 1
  store i1 %0, i1* %2, align 1
  %3 = load i1, i1* %2, align 1
  br i1 %3, label %then, label %end

then:                                             ; preds = %1
  ret i8* getelementptr inbounds ([5 x i8], [5 x i8]* @0, i32 0, i32 0)

end:                                              ; preds = %1
  ret i8* getelementptr inbounds ([6 x i8], [6 x i8]* @1, i32 0, i32 0)
}

define i1 @validate(%Sieve %0, i32 %1) {
  %3 = alloca %Sieve, align 8
  store %Sieve %0, %Sieve* %3, align 8
  %4 = alloca i32, align 4
  store i32 %1, i32* %4, align 4
  %5 = getelementptr inbounds %Sieve, %Sieve* %3, i32 0, i32 0
  %6 = load i32, i32* %5, align 4
  %7 = icmp eq i32 %6, 10
  br i1 %7, label %then, label %end

then:                                             ; preds = %2
  %8 = load i32, i32* %4, align 4
  %9 = icmp eq i32 %8, 1
  ret i1 %9

end:                                              ; preds = %2
  %10 = getelementptr inbounds %Sieve, %Sieve* %3, i32 0, i32 0
  %11 = load i32, i32* %10, align 4
  %12 = icmp eq i32 %11, 100
  br i1 %12, label %then1, label %end2

then1:                                            ; preds = %end
  %13 = load i32, i32* %4, align 4
  %14 = icmp eq i32 %13, 25
  ret i1 %14

end2:                                             ; preds = %end
  %15 = getelementptr inbounds %Sieve, %Sieve* %3, i32 0, i32 0
  %16 = load i32, i32* %15, align 4
  %17 = icmp eq i32 %16, 1000
  br i1 %17, label %then3, label %end4

then3:                                            ; preds = %end2
  %18 = load i32, i32* %4, align 4
  %19 = icmp eq i32 %18, 168
  ret i1 %19

end4:                                             ; preds = %end2
  %20 = getelementptr inbounds %Sieve, %Sieve* %3, i32 0, i32 0
  %21 = load i32, i32* %20, align 4
  %22 = icmp eq i32 %21, 10000
  br i1 %22, label %then5, label %end6

then5:                                            ; preds = %end4
  %23 = load i32, i32* %4, align 4
  %24 = icmp eq i32 %23, 1229
  ret i1 %24

end6:                                             ; preds = %end4
  %25 = getelementptr inbounds %Sieve, %Sieve* %3, i32 0, i32 0
  %26 = load i32, i32* %25, align 4
  %27 = icmp eq i32 %26, 100000
  br i1 %27, label %then7, label %end8

then7:                                            ; preds = %end6
  %28 = load i32, i32* %4, align 4
  %29 = icmp eq i32 %28, 9592
  ret i1 %29

end8:                                             ; preds = %end6
  %30 = getelementptr inbounds %Sieve, %Sieve* %3, i32 0, i32 0
  %31 = load i32, i32* %30, align 4
  %32 = icmp eq i32 %31, 1000000
  br i1 %32, label %then9, label %end10

then9:                                            ; preds = %end8
  %33 = load i32, i32* %4, align 4
  %34 = icmp eq i32 %33, 78498
  ret i1 %34

end10:                                            ; preds = %end8
  %35 = getelementptr inbounds %Sieve, %Sieve* %3, i32 0, i32 0
  %36 = load i32, i32* %35, align 4
  %37 = icmp eq i32 %36, 10000000
  br i1 %37, label %then11, label %end12

then11:                                           ; preds = %end10
  %38 = load i32, i32* %4, align 4
  %39 = icmp eq i32 %38, 664579
  ret i1 %39

end12:                                            ; preds = %end10
  %40 = getelementptr inbounds %Sieve, %Sieve* %3, i32 0, i32 0
  %41 = load i32, i32* %40, align 4
  %42 = icmp eq i32 %41, 100000000
  br i1 %42, label %then13, label %end14

then13:                                           ; preds = %end12
  %43 = load i32, i32* %4, align 4
  %44 = icmp eq i32 %43, 5761455
  ret i1 %44

end14:                                            ; preds = %end12
  ret i1 false
}

define void @printSieve(i1 %0, %Sieve %1, double %2, i32 %3) {
  %5 = alloca i1, align 1
  store i1 %0, i1* %5, align 1
  %6 = alloca %Sieve, align 8
  store %Sieve %1, %Sieve* %6, align 8
  %7 = alloca double, align 8
  store double %2, double* %7, align 8
  %8 = alloca i32, align 4
  store i32 %3, i32* %8, align 4
  %count = alloca i32, align 4
  store i32 0, i32* %count, align 4
  %p = alloca i32, align 4
  store i32 2, i32* %p, align 4
  br label %for-loop

for-loop:                                         ; preds = %end, %4
  %9 = load i32, i32* %p, align 4
  %10 = getelementptr inbounds %Sieve, %Sieve* %6, i32 0, i32 0
  %11 = load i32, i32* %10, align 4
  %12 = icmp sle i32 %9, %11
  br i1 %12, label %for-then, label %for-end

for-then:                                         ; preds = %for-loop
  %13 = getelementptr inbounds %Sieve, %Sieve* %6, i32 0, i32 1
  %14 = load i1*, i1** %13, align 8
  %15 = load i32, i32* %p, align 4
  %16 = getelementptr inbounds i1, i1* %14, i32 %15
  %17 = load i1, i1* %16, align 1
  br i1 %17, label %then, label %end

for-end:                                          ; preds = %for-loop
  %18 = load i32, i32* %8, align 4
  %19 = load double, double* %7, align 8
  %20 = load double, double* %7, align 8
  %21 = load i32, i32* %8, align 4
  %22 = sitofp i32 %21 to double
  %23 = fdiv double %20, %22
  %24 = getelementptr inbounds %Sieve, %Sieve* %6, i32 0, i32 0
  %25 = load i32, i32* %24, align 4
  %26 = load i32, i32* %count, align 4
  %27 = load %Sieve, %Sieve* %6, align 8
  %28 = load i32, i32* %count, align 4
  %29 = call i1 @validate(%Sieve %27, i32 %28)
  %30 = call i8* @bool2str(i1 %29)
  call void (i8*, ...) @printf(i8* getelementptr inbounds ([64 x i8], [64 x i8]* @3, i32 0, i32 0), i32 %18, double %19, double %23, i32 %25, i32 %26, i8* %30)
  ret void

then:                                             ; preds = %for-then
  %31 = load i1, i1* %5, align 1
  br i1 %31, label %then1, label %end2

end:                                              ; preds = %end2, %for-then
  %32 = load i32, i32* %p, align 4
  %33 = add i32 %32, 1
  store i32 %33, i32* %p, align 4
  br label %for-loop

then1:                                            ; preds = %then
  %34 = load i32, i32* %p, align 4
  call void (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @2, i32 0, i32 0), i32 %34)
  br label %end2

end2:                                             ; preds = %then1, %then
  %35 = load i32, i32* %count, align 4
  %36 = add i32 %35, 1
  store i32 %36, i32* %count, align 4
  br label %end
}

define %Sieve @sieve(i32 %0) {
  %2 = alloca i32, align 4
  store i32 %0, i32* %2, align 4
  %3 = load i32, i32* %2, align 4
  %4 = add i32 %3, 1
  %5 = call i8* @malloc(i32 %4)
  %6 = bitcast i8* %5 to i1*
  %prime = alloca i1*, align 8
  store i1* %6, i1** %prime, align 8
  %7 = load i1*, i1** %prime, align 8
  %8 = bitcast i1* %7 to i8*
  %9 = load i32, i32* %2, align 4
  %10 = add i32 %9, 1
  call void @memset(i8* %8, i8 -1, i32 %10)
  %p = alloca i32, align 4
  store i32 2, i32* %p, align 4
  br label %for-loop

for-loop:                                         ; preds = %end, %1
  %11 = load i32, i32* %p, align 4
  %12 = load i32, i32* %p, align 4
  %13 = mul i32 %11, %12
  %14 = load i32, i32* %2, align 4
  %15 = icmp sle i32 %13, %14
  br i1 %15, label %for-then, label %for-end

for-then:                                         ; preds = %for-loop
  %16 = load i1*, i1** %prime, align 8
  %17 = load i32, i32* %p, align 4
  %18 = getelementptr inbounds i1, i1* %16, i32 %17
  %19 = load i1, i1* %18, align 1
  br i1 %19, label %then, label %end

for-end:                                          ; preds = %for-loop
  %20 = load i1*, i1** %prime, align 8
  %21 = bitcast i1* %20 to i8*
  call void @free(i8* %21)
  %22 = alloca %Sieve, align 8
  %23 = load i32, i32* %2, align 4
  %24 = getelementptr inbounds %Sieve, %Sieve* %22, i32 0, i32 0
  store i32 %23, i32* %24, align 4
  %25 = load i1*, i1** %prime, align 8
  %26 = getelementptr inbounds %Sieve, %Sieve* %22, i32 0, i32 1
  store i1* %25, i1** %26, align 8
  %27 = load %Sieve, %Sieve* %22, align 8
  ret %Sieve %27

then:                                             ; preds = %for-then
  %28 = load i32, i32* %p, align 4
  %29 = load i32, i32* %p, align 4
  %30 = mul i32 %28, %29
  %i = alloca i32, align 4
  store i32 %30, i32* %i, align 4
  br label %for-loop1

end:                                              ; preds = %for-end3, %for-then
  %31 = load i32, i32* %p, align 4
  %32 = add i32 %31, 1
  store i32 %32, i32* %p, align 4
  br label %for-loop

for-loop1:                                        ; preds = %for-then2, %then
  %33 = load i32, i32* %i, align 4
  %34 = load i32, i32* %2, align 4
  %35 = icmp sle i32 %33, %34
  br i1 %35, label %for-then2, label %for-end3

for-then2:                                        ; preds = %for-loop1
  %36 = load i1*, i1** %prime, align 8
  %37 = load i32, i32* %i, align 4
  %38 = getelementptr inbounds i1, i1* %36, i32 %37
  %39 = load i1, i1* %38, align 1
  %40 = load i1*, i1** %prime, align 8
  %41 = load i32, i32* %i, align 4
  %42 = getelementptr inbounds i1, i1* %40, i32 %41
  store i1 false, i1* %42, align 1
  %43 = load i32, i32* %i, align 4
  %44 = load i32, i32* %p, align 4
  %45 = add i32 %43, %44
  store i32 %45, i32* %i, align 4
  br label %for-loop1

for-end3:                                         ; preds = %for-loop1
  br label %end
}

declare void @puts(i8*)

declare void @printf.1(i8*, ...)

 %39 = icmp sle i32 %37, %38
  br i1 %39, label %for-then2, label %for-end3

for-then2:                                        ; preds = %for-loop1
  %40 = load i1*, i1** %prime, align 8
  %41 = load i32, i32* %i, align 4
  %42 = getelementptr inbounds i1, i1* %40, i32 %41
  %43 = load i1, i1* %42, align 1
  br i1 %43, label %then4, label %end5

for-end3:                                         ; preds = %for-loop1
  br label %end

then4:                                            ; preds = %for-then2
  %44 = load i32, i32* %count, align 4
  %45 = sub i32 %44, 1
  store i32 %45, i32* %count, align 4
  br label %end5

end5:                                             ; preds = %then4, %for-then2
  %46 = load i1*, i1** %prime, align 8
  %47 = load i32, i32* %i, align 4
  %48 = getelementptr inbounds i1, i1* %46, i32 %47
  %49 = load i1, i1* %48, align 1
  %50 = load i1*, i1** %prime, align 8
  %51 = load i32, i32* %i, align 4
  %52 = getelementptr inbounds i1, i1* %50, i32 %51
  store i1 false, i1* %52, align 1
  %53 = load i32, i32* %i, align 4
  %54 = load i32, i32* %p, align 4
  %55 = add i32 %53, %54
  store i32 %55, i32* %i, align 4
  br label %for-loop1
}

declare void @puts(i8*)

declare void @printf.1(i8*, ...)

